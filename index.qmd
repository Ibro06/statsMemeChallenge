---
title: "Selection Bias & Missing Data Challenge - Part 2"
subtitle: "Creating a Statistics Meme: Visualizing Selection Bias"
format:
  html: default
execute:
  echo: false
  eval: true
---

# ðŸŽ¨ Selection Bias & Missing Data Challenge - Part 2

## My Statistics Meme: Visualizing Selection Bias

This meme demonstrates selection bias by showing how systematic missing data patterns can distort our understanding of reality.

```{python}
#| label: generate-meme
#| echo: false
#| fig-cap: "Four-panel statistics meme: Reality (original image), Your Model (stippled version), Selection Bias (letter S), and Estimate (masked stippled image)"

import numpy as np
from PIL import Image, ImageDraw, ImageFont
import matplotlib.pyplot as plt
import random

# Try to import scipy for smoothing, but fall back if not available
try:
    from scipy.ndimage import gaussian_filter
    has_scipy = True
except ImportError:
    has_scipy = False

# Load original image
original_img = Image.open('40FCF51B-3864-4005-86C0-19561AC53EAD_1_105_c.jpeg')
if original_img.mode != 'L':
    original_img = original_img.convert('L')

# Resize if too large (for performance)
max_size = 1200
if max(original_img.size) > max_size:
    ratio = max_size / max(original_img.size)
    new_size = (int(original_img.size[0] * ratio), int(original_img.size[1] * ratio))
    original_img = original_img.resize(new_size, Image.Resampling.LANCZOS)

original_array = np.array(original_img, dtype=np.float32) / 255.0
height, width = original_array.shape

# Create stippled version
# Convert to probability map (darker = higher probability of dots)
inverted = 1.0 - original_array
# Add some smoothing to make stippling more coherent
if has_scipy:
    inverted_smooth = gaussian_filter(inverted, sigma=2.0)
else:
    # Fallback to no smoothing if scipy not available
    inverted_smooth = inverted

# Generate stippled image
stipple_array = np.ones((height, width), dtype=np.float32)
num_points = int(height * width * 0.15)  # About 15% density

# Use weighted random sampling based on image intensity
for _ in range(num_points):
    # Sample based on probability (darker areas more likely)
    prob_map = inverted_smooth / inverted_smooth.sum()
    flat_idx = np.random.choice(height * width, p=prob_map.flatten())
    y, x = divmod(flat_idx, width)

    # Draw a small dot
    dot_size = 1
    y_min = max(0, y - dot_size)
    y_max = min(height, y + dot_size + 1)
    x_min = max(0, x - dot_size)
    x_max = min(width, x + dot_size + 1)
    stipple_array[y_min:y_max, x_min:x_max] = 0.0

# Create the "S" mask
s_img = Image.new('L', (width, height), 255)
draw = ImageDraw.Draw(s_img)

# Use a large, bold font - try multiple bold font paths
font_size = int(height * 0.85)
font = None

# Try multiple bold font options
font_paths = [
    "/System/Library/Fonts/Supplemental/Arial Bold.ttf",
    "/System/Library/Fonts/Supplemental/Arial.ttf",
    "/System/Library/Fonts/Helvetica.ttc",
    "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
    "/Library/Fonts/Arial Bold.ttf",
    "/Library/Fonts/Arial.ttf"
]

for font_path in font_paths:
    try:
        font = ImageFont.truetype(font_path, font_size)
        break
    except:
        continue

if font is None:
    # Fallback to default font, make it bold by drawing multiple times
    font = ImageFont.load_default()
    font_size = int(height * 0.6)

# Get text bounding box and center it
bbox = draw.textbbox((0, 0), "S", font=font)
text_width = bbox[2] - bbox[0]
text_height = bbox[3] - bbox[1]
x_pos = (width - text_width) // 2 - bbox[0]
y_pos = (height - text_height) // 2 - bbox[1]

# Draw the "S" in black - draw multiple times to make it bolder if using default font
if "Bold" not in str(font) and font_paths[-1] not in str(font):
    # Draw multiple times with slight offsets to make bold
    offsets = [(0, 0), (-1, 0), (1, 0), (0, -1), (0, 1)]
    for dx, dy in offsets:
        draw.text((x_pos + dx, y_pos + dy), "S", fill=0, font=font)
else:
    draw.text((x_pos, y_pos), "S", fill=0, font=font)

s_array = np.array(s_img, dtype=np.float32) / 255.0

# Create masked estimate with smooth blending
# Make the "S" area blend naturally by gradually fading out dots
estimate_array = stipple_array.copy()

# Create a smooth gradient mask for the S area
# Use the inverted S array as a mask (where S is dark, we want to remove/fade dots)
s_mask_inv = 1.0 - s_array  # Invert so S areas are bright (1.0) and background is dark (0.0)

# Apply smoothing to the mask edges for smoother blending
if has_scipy:
    s_mask_smooth = gaussian_filter(s_mask_inv, sigma=3.0)
else:
    s_mask_smooth = s_mask_inv

# Blend the stippled image with white in the S area
# The more the mask value, the more we fade to white (removing dots)
# This creates a smooth transition rather than a hard cut
blend_strength = s_mask_smooth * 0.85  # Scale the mask (0.85 = 85% fade)
estimate_array = estimate_array * (1.0 - blend_strength) + blend_strength

# Create four-panel meme matching the example style
# Each panel has a pink header bar above a white image background
fig = plt.figure(figsize=(20, 6))
fig.patch.set_facecolor('#ffe0e6')  # Light pink background

labels = ["Reality", "Your Model", "Selection Bias", "Estimate"]
arrays = [original_array, stipple_array, s_array, estimate_array]

# Panel layout parameters
num_panels = 4
panel_width = 0.23
spacing = 0.01
left_margin = 0.01
image_height = 0.75
header_height = 0.15
bottom_margin = 0.05

# Create each panel with pink header and white image area
for i, (label, arr) in enumerate(zip(labels, arrays)):
    # Calculate position for this panel
    left = left_margin + i * (panel_width + spacing)
    
    # Create pink header bar
    header_ax = fig.add_axes([left, bottom_margin + image_height, panel_width, header_height])
    header_ax.set_facecolor('#ffe0e6')  # Pink background for header
    header_ax.text(0.5, 0.5, label, ha='center', va='center', 
                   fontsize=16, fontweight='bold', color='black',
                   transform=header_ax.transAxes)
    header_ax.set_xlim(0, 1)
    header_ax.set_ylim(0, 1)
    header_ax.axis('off')
    
    # Create image area with white background
    ax = fig.add_axes([left, bottom_margin, panel_width, image_height])
    ax.set_facecolor('white')  # White background for image
    ax.imshow(arr, cmap='gray', vmin=0, vmax=1, aspect='auto', 
              interpolation='nearest')
    ax.axis('off')

plt.savefig('statistics_meme.png', dpi=200, bbox_inches='tight', facecolor='#ffe0e6')
plt.close()
```

![My statistics meme showing the four-panel structure](statistics_meme.png)

## Explanation: What is Selection Bias?

Selection bias occurs when the data we observe isn't representative of the population we're trying to understand. This meme visually demonstrates this concept:

1. **Reality** (Panel 1): The original photograph represents the true population or phenomenon we want to study.

2. **Your Model** (Panel 2): The stippled version represents our sampled dataâ€”a simplified model that captures key features but with reduced detail. This is like survey data or observational studies.

3. **Selection Bias** (Panel 3): The bold letter "S" represents a systematic pattern in how data goes missing. Just like the "S" shape, selection bias isn't randomâ€”it follows a pattern that can skew our understanding.

4. **Estimate** (Panel 4): When we apply the selection bias pattern to our model, we see a distorted view. Data points in the "S" shape are missing, creating a biased estimate that no longer accurately represents reality.

**The Key Insight:** When selection bias is present, our estimates can be systematically wrong. The missing data isn't randomâ€”it follows a pattern (represented by the "S") that excludes certain parts of the population or phenomenon. This is why it's crucial to ask: **"Does my sample match my population of interest?"**

This visualization helps us remember that selection bias isn't just a statistical conceptâ€”it's a real-world problem that can lead us to incorrect conclusions if we're not careful about how we collect and analyze data.

